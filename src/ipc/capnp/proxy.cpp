// make ipc/capnp/messages.capnp.proxy.c++

#include <boost/core/explicit_operator_bool.hpp>
#include <boost/optional/optional.hpp>
#include <capnp/blob.h>
#include <capnp/schema-parser.h>
#include <capnp/schema.capnp.h>
#include <capnp/schema.h>
#include <kj/common.h>
#include <kj/string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <cctype>
#include <map>
#include <memory>
#include <fstream>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#define PROXY_BIN "ipc/capnp/proxy"

static constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp
static constexpr uint64_t INCLUDE_ANNOTATION_ID = 0xb899f3c154fdb458ull;   // From proxy.capnp
static constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp
static constexpr uint64_t CLIENT_ANNOTATION_ID = 0x917feb69b40356d5ull;    // From proxy.capnp
static constexpr uint64_t SERVER_ANNOTATION_ID = 0x90fc439a543e651bull;    // From proxy.capnp
static constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp
static constexpr uint64_t ASYNC_ANNOTATION_ID = 0x82691dae52a0a145ull;     // From proxy.capnp

template <typename Reader>
boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)
{
    for (const auto& annotation : reader.getAnnotations()) {
        if (annotation.getId() == id) return annotation.getValue();
    }
    return {};
}

using CharSlice = kj::ArrayPtr<const char>;

// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.
template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>
OutputStream& operator<<(OutputStream& os, const Array& array)
{
    os.write(array.begin(), array.size());
    return os;
}

std::string Cap(kj::StringPtr str)
{
    std::string result = str;
    if (!result.empty()) result[0] = toupper(result[0]);
    return result;
}

bool PrimitiveType(const ::capnp::Type& type)
{
    return type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||
           type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||
           type.isFloat64();
}

void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)
{
    std::string stem = output_stem;
    std::ofstream cpp(stem + ".proxy.c++");
    stem += ".proxy.h";
    std::ofstream h(stem);
    cpp << "// Generated by " PROXY_BIN " from " << input_schema << "\n\n";
    cpp << "#include <" << stem << ">\n";
    cpp << "namespace ipc {\n";
    cpp << "namespace capnp {\n";

    h << "// Generated by " PROXY_BIN " from " << input_schema << "\n\n";
    std::transform(stem.begin(), stem.end(), stem.begin(),
        [](unsigned char c) { return std::isalnum(c) ? std::toupper(c) : '_'; });
    h << "#ifndef " << stem << "\n";
    h << "#define " << stem << "\n\n";

    capnp::SchemaParser parser;
    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});

    for (const auto& annotation : file_schema.getProto().getAnnotations()) {
        if (annotation.getId() == INCLUDE_ANNOTATION_ID) {
            h << "#include <" << annotation.getValue().getText() << ">\n";
        }
    }
    h << "#include <" << input_schema << ".h>\n";
    h << "#include <ipc/capnp/util.h>\n\n";

    h << "namespace ipc {\n";
    h << "namespace capnp {\n";

    kj::StringPtr message_namespace;
    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {
        message_namespace = value->getText();
    }

    for (const auto& node_nested : file_schema.getProto().getNestedNodes()) {
        kj::StringPtr node_name = node_nested.getName();
        const auto& node = file_schema.getNested(node_name);
        kj::StringPtr proxied_class_type;
        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {
            proxied_class_type = proxy->getText();
        }
        kj::StringPtr proxied_client_type = proxied_class_type;
        if (auto client = GetAnnotation(node.getProto(), CLIENT_ANNOTATION_ID)) {
            proxied_client_type = client->getText();
        }
        kj::StringPtr server_base_type = "";
        if (auto server = GetAnnotation(node.getProto(), SERVER_ANNOTATION_ID)) {
            server_base_type = server->getText();
        }
        if (node.getProto().isInterface()) {
            const auto& interface = node.asInterface();

            h << "\ntemplate<>\n";
            h << "class Proxy<" << message_namespace << "::" << node_name << "> {\n";
            h << "public:\n";
            h << "    class Client;\n";
            h << "    class Server;\n";
            h << "};\n";

            std::ostringstream client;
            client << "class Proxy<" << message_namespace << "::" << node_name << ">::Client : ";
            if (proxied_client_type.size()) {
                client << "public " << proxied_client_type << ", ";
            }
            client << "public ProxyClientBase<" << message_namespace << "::" << node_name << "> {\n";
            client << "public:\n";
            client << "    using ProxyClientBase<" << message_namespace << "::" << node_name
                   << ">::ProxyClientBase;\n";

            std::ostringstream server;
            server << "class Proxy<" << message_namespace << "::" << node_name << ">::Server final : public ";
            if (server_base_type.size()) {
                server << server_base_type;
            } else {
                server << message_namespace << "::" << node_name << "::Server, public ProxyServerBase";
            }
            server << "\n{\npublic:\n";

            // List of methods with proxied_method_type annotations.
            std::vector<std::pair<int, kj::StringPtr>> proxied_methods;

            for (const auto& method : interface.getMethods()) {
                kj::StringPtr method_name = method.getProto().getName();
                kj::StringPtr client_method_name = method_name;
                bool server_async = false;
                if (auto async = GetAnnotation(method.getProto(), ASYNC_ANNOTATION_ID)) {
                    server_async = true;
                }
                if (auto client = GetAnnotation(method.getProto(), CLIENT_ANNOTATION_ID)) {
                    client_method_name = client->getText();
                }
                kj::StringPtr server_method_name;
                if (auto server = GetAnnotation(method.getProto(), SERVER_ANNOTATION_ID)) {
                    server_method_name = server->getText();
                }
                kj::StringPtr proxied_method_type;
                if (auto proxy = GetAnnotation(method.getProto(), PROXY_ANNOTATION_ID)) {
                    proxied_method_type = proxy->getText();
                    proxied_methods.emplace_back(method.getOrdinal(), proxied_method_type);
                } else if (!proxied_class_type.size()) {
                    continue;
                }

                struct Field
                {
                    boost::optional<::capnp::StructSchema::Field> param;
                    boost::optional<::capnp::StructSchema::Field> result;
                    int args = 0;
                    bool retval = false;
                    bool optional = false;

                    bool hasHas() const { return param && !PrimitiveType(param->getType()); }
                };

                std::vector<Field> fields;
                std::map<kj::StringPtr, int> field_idx; // name -> args index
                bool has_result = false;

                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {
                    auto field_name = schema_field.getProto().getName();
                    auto inserted = field_idx.emplace(field_name, fields.size());
                    if (inserted.second) {
                        fields.emplace_back();
                    }
                    auto& field = fields[inserted.first->second];
                    (param ? field.param : field.result) = schema_field;

                    if (!param && field_name == "result") {
                        field.retval = true;
                        has_result = true;
                    }

                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {
                        field.args += value->getInt32();
                    } else if (inserted.second) {
                        if (!param && field_name == "result") {
                            field.retval = true;
                        } else if (param || (field_name != "error" && field_name != "rpcError")) {
                            // FIXME: error and rpcError should be detected with
                            // exception annotations
                            field.args = 1;
                        }
                    }
                };

                for (const auto& schema_field : method.getParamType().getFields()) {
                    add_field(schema_field, true);
                }
                for (const auto& schema_field : method.getResultType().getFields()) {
                    add_field(schema_field, false);
                }
                for (auto& field : field_idx) {
                    auto has_field = field_idx.find("has" + Cap(field.first));
                    if (has_field != field_idx.end() && !fields[field.second].hasHas()) {
                        fields[has_field->second].args = 0;
                        fields[field.second].optional = true;
                    }
                }

                std::ostringstream client_args;
                std::ostringstream client_invoke;
                std::ostringstream server_invoke;
                int argc = 0;
                for (const auto& field : fields) {
                    auto field_name = field.param ? field.param->getProto().getName() :
                                                    field.result ? field.result->getProto().getName() : "";

                    for (int i = 0; i < field.args; ++i) {
                        if (argc > 0) client_args << ",";
                        client_args << "M" << method.getOrdinal() << "::Arg<" << argc << "> " << field_name;
                        if (field.args > 1) client_args << i;
                        ++argc;
                    }

                    if (field.retval || field.args > 0) {
                        client_invoke << ", MakeClientArg<" << argc << "/*DEBUG*/>(MakeAccessor(";
                        if (field.result) {
                            client_invoke << "&" << message_namespace << "::" << node_name << "::" << Cap(method_name)
                                          << "Results::Reader::get" << Cap(field_name);
                        } else {
                            client_invoke << "nullptr";
                        }
                        client_invoke << ", ";
                        if (field.param) {
                            auto t = field.param->getType();
                            if (t.isInterface()) {
                                const auto& interface = t.asInterface();
                                client_invoke << "static_cast<void (" << message_namespace << "::" << node_name
                                              << "::" << Cap(method_name) << "Params::Builder::*)("
                                              << message_namespace << "::" << interface.getShortDisplayName()
                                              << "::Client&&)>(";
                            }
                            client_invoke << "&" << message_namespace << "::" << node_name << "::" << Cap(method_name)
                                          << "Params::Builder::";
                            client_invoke
                                << (PrimitiveType(field.param->getType()) || field.param->getType().isInterface() ?
                                        "set" :
                                        "init");
                            client_invoke << Cap(field_name);
                            if (t.isInterface()) {
                                client_invoke << ")";
                            }
                        } else {
                            client_invoke << "nullptr";
                        }
                        client_invoke << ", ";
                        if (field.optional) {
                            client_invoke << "&" << message_namespace << "::" << node_name << "::" << Cap(method_name)
                                          << "Params::Reader::getHas" << Cap(field_name) << ", ";
                            client_invoke << "&" << message_namespace << "::" << node_name << "::" << Cap(method_name)
                                          << "Params::Builder::setHas" << Cap(field_name);
                        } else if (field.hasHas()) {
                            client_invoke << "&" << message_namespace << "::" << node_name << "::" << Cap(method_name)
                                          << "Params::Reader::has" << Cap(field_name) << ", nullptr";
                        } else {
                            client_invoke << "nullptr, nullptr";
                        }
                        client_invoke << ")";

                        if (field.retval == 1 || field.args == 1) {
                            client_invoke << ", " << field_name;
                        } else {
                            for (int i = 0; i < field.args; ++i) {
                                client_invoke << ", " << field_name << i;
                            }
                        }
                        client_invoke << ")";
                    }

                    if (field.args > 0 || field.retval) { // FIXME remove condition?
                        server_invoke << ", ";
                        server_invoke << (field.retval ? "MakeServerFieldRet" : "MakeServerField");
                        if (!field.retval && field.args != 1) {
                            server_invoke << "<" << field.args << ">";
                        }
                        server_invoke << "(MakeAccessor(";
                        if (field.param) {
                            server_invoke << "&" << Cap(method_name) << "Params::Reader::get" << Cap(field_name);
                        } else {
                            server_invoke << "nullptr";
                        }
                        server_invoke << ", ";
                        if (field.result) {
                            // FIXME: dedup with client
                            auto t = field.result->getType();
                            if (t.isInterface()) {
                                const auto& interface = t.asInterface();
                                server_invoke << "static_cast<void (" << message_namespace << "::" << node_name
                                              << "::" << Cap(method_name) << "Results::Builder::*)("
                                              << message_namespace << "::" << interface.getShortDisplayName()
                                              << "::Client&&)>(";
                            }
                            server_invoke << "&" << message_namespace << "::" << node_name << "::" << Cap(method_name)
                                          << "Results::Builder::";
                            server_invoke
                                << (PrimitiveType(field.result->getType()) || field.result->getType().isInterface() ?
                                        "set" :
                                        "init");
                            server_invoke << Cap(field_name);
                            if (t.isInterface()) {
                                server_invoke << ")";
                            }
                        } else {
                            server_invoke << "nullptr";
                        }

                        // FIXME: dedup with client
                        server_invoke << ", ";
                        if (field.optional) {
                            server_invoke << "&" << Cap(method_name) << "Params::Reader::getHas" << Cap(field_name)
                                          << ", ";
                            server_invoke << "&" << Cap(method_name) << "Params::Builder::setHas" << Cap(field_name);
                        } else if (field.hasHas()) {
                            server_invoke << "&" << Cap(method_name) << "Params::Reader::has" << Cap(field_name)
                                          << ", nullptr";
                        } else {
                            server_invoke << "nullptr, nullptr";
                        }
                        server_invoke << "))";
                    }
                }

                client << "    using M" << method.getOrdinal() << " = Method<";
                if (proxied_method_type.size()) {
                    client << "typename " << proxied_method_type;
                } else {
                    client << "decltype(&" << proxied_client_type << "::" << client_method_name << ")";
                }
                client << ">;\n";
                client << "    typename M" << method.getOrdinal() << "::Result " << client_method_name << "("
                       << client_args.str() << ")";
                if (!proxied_method_type.size()) {
                    // If method doesn't have its own proxy annotation, then it must be
                    // overriding a virtual method inherited from
                    // proxied_class_type.
                    client << " override";
                }
                client << ";\n";
                cpp << "typename Proxy<" << message_namespace << "::" << node_name << ">::Client::M"
                    << method.getOrdinal() << "::Result Proxy<" << message_namespace << "::" << node_name
                    << ">::Client::" << client_method_name << "(" << client_args.str() << ") {\n";
                if (has_result) {
                    // FIXME: Invoke function should just return the result directly to simplify proxy gen and get rid
                    // of need for this variable. This would also unify server & client implementations.
                    cpp << "    typename M" << method.getOrdinal() << "::Result result;\n";
                }
                cpp << "    invoke(M" << method.getOrdinal() << "(), &" << message_namespace << "::" << node_name
                    << "::Client::" << method_name << "Request" << client_invoke.str() << ");\n";
                if (has_result) cpp << "    return result;\n";
                cpp << "    }\n";

                server << "    kj::Promise<void> " << method_name << "(" << Cap(method_name)
                       << "Context context) override;\n";
                cpp << "kj::Promise<void> Proxy<" << message_namespace << "::" << node_name
                    << ">::Server::" << method_name << "(" << Cap(method_name) << "Context context) {\n";
                if (server_method_name.size()) {
                    cpp << "    return " << server_base_type << "::" << server_method_name << "(*m_impl, context);\n";
                } else {
                    cpp << "    return " << (proxied_method_type.size() ? "invokeFunction" : "invokeMethod")
                        << (server_async ? "Async" : "") << "(context";
                    if (proxied_method_type.size()) {
                        cpp << ", m_impl" << method.getOrdinal();
                    } else {
                        cpp << ", *m_impl, &" << proxied_class_type << "::" << method_name;
                    }
                    cpp << server_invoke.str() << ");\n";
                }
                cpp << "}\n";
            }

            server << "\n    template<typename... FwdArgs>";
            server << "\n    Server(";
            if (proxied_class_type.size()) {
                server << "std::unique_ptr<" << proxied_class_type << "> impl, ";
            }
            for (const auto& proxied_method : proxied_methods) {
                server << proxied_method.second << " impl" << proxied_method.first << ", ";
            }
            server << "FwdArgs&&... fwd_args) : ";
            if (server_base_type.size()) {
                server << server_base_type;
            } else {
                server << "ProxyServerBase";
            }
            server << "(std::forward<FwdArgs>(fwd_args)...)";
            if (proxied_class_type.size()) {
                server << ", m_impl(std::move(impl))";
            }
            for (const auto& proxied_method : proxied_methods) {
                server << ", m_impl" << proxied_method.first << "(std::move(impl" << proxied_method.first << "))";
            }
            server << " {}\n";
            if (proxied_class_type.size()) {
                server << "\n    std::unique_ptr<" << proxied_class_type << "> m_impl;\n";
            }
            for (const auto& proxied_method : proxied_methods) {
                server << "    " << proxied_method.second << " m_impl" << proxied_method.first << ";\n";
            }
            client << "};\n";
            server << "};\n";
            h << "\n" << client.str();
            h << "\n" << server.str();
            h << "\n";
        }
    }

    cpp << "} // namespace capnp\n";
    cpp << "} // namespace ipc\n";
    h << "} // namespace capnp\n";
    h << "} // namespace ipc\n";

    h << "#endif\n";
}

int main(int argc, char** argv)
{
    if (argc != 4) {
        fprintf(stderr, "Usage: " PROXY_BIN " INPUT_SCHEMA IMPORT_PATH OUTPUT_STEM\n");
        exit(1);
    }
    Generate(argv[1], argv[2], argv[3]);
    return 0;
}
